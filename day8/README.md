# Day 8: Memory Maneuver

Recursion! I love recursion. There is some elegance to it that really tops my taco. I may have [mentioned this](https://github.com/AgroDan/aoc2024/tree/main/day15) a few times in the past, but recursive functions are some of my favorite. In a way it's the quintessential method for dividing and conquering. "Do this one simple calculation _if and only if_ this other condition is met. Otherwise move the pointer and call yourself again, adding the value from the result of this function." This challenge really emphasized just how useful recursive functions can be.

The first part was undoubtedly the hardest section of this challenge. You have this linear set of numbers that all refer to a list of nodes within a tree structure, but it's _layered_, meaning that there are two parts of data to ingest, the first being the header values, the second being the metadata. At first I started thinking I would need a [Deque](https://en.wikipedia.org/wiki/Double-ended_queue) (btw, pronounced "Deck", not "de-queue"), so I started coding that in my [aocutils module](https://github.com/AgroDan/aocutils), but it turns out that it was completely unnecessary since the proper way of handling this was, of course, recursion. Basically ingest the first two numbers by referencing them via a cursor, setting them to the amount of children and metadata items respectively, then if there _are_ children, call itself again while updating the cursor to the start of the next node. Keep doing this until it comes across a node with no children, then take the amount of metadata and and return -- each recursion will add the node to one of its children and then repeat until we get all the children. Do this and you'll get a full tree representation. Then just walk the tree and add up all the metadata values to get part one. You'll see some dead functions that don't do anything while I tried a few things first that wound up dying on the vine. I leave that to you, dear reader (whoever you may be) to witness how bad I am at this.

Part two, once part one was finished, was almost _too_ easy. Same basic idea, recurse all the way down until you get a node without children, then add the metadata. Otherwise collect the sums of the referenced nodes (working around Eric Wastl's "index starts at 1" nonsense that he must have learned from Perl) and move on. This worked pretty well.

Finished part 1 and 2 after about `1.1508ms`.

> BTW, no shade at Eric. He's the only Perl programmer I can forgive.